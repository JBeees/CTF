# TITLE : buffer overflow 0
## Author : Alex Fulton / Palash Oswal

## Description
Let's start off simple, can you overflow the correct buffer? The program is available here. You can view source here.
Additional details will be available after launching your challenge instance.

## Hints
- How can you trigger the flag to print?
- If you try to do the math by hand, maybe try and add a few more characters. Sometimes there are things you aren't expecting.
- Run man gets and read the BUGS section. How many characters can the program really read?

## Solution
In this challenge, we are dealing with a **buffer overflow vulnerability**, A buffer overflow (or buffer overrun) occurs when the volume of data exceeds the storage capacity of the memory buffer. it can cause the program to behave unpredictably and generate incorrect results, memory access errors, or crashes[^1].
From the provided source code, we can observe two unsafe functions:
- `gets(buf1)` — reads input without bounds checking.
- `strcpy(buf2, input)` — copies input into a 16-byte buffer without verifying the input length.

These two functions together create a classic buffer overflow scenario. The goal is to trigger a segmentation fault, which will invoke the custom `sigsegv_handler`  
To exploit this, simply provide more than 16 characters of input. This will overflow buf2, corrupt the stack, and eventually cause a crash. Once a segmentation fault occurs, the signal handler will execute and print the flag.

[^1]: https://www.imperva.com/learn/application-security/buffer-overflow/ 
